#  Chapter 0. 컴파일러(Compiler)와 인터프리터(Interpreter)

> [참고자료 1](https://velog.io/@jhur98/%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%ACcompiler%EC%99%80-%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0interpreter%EC%9D%98-%EC%B0%A8%EC%9D%B4)
> 
> [참고자료 2](https://jhyonhyon.tistory.com/18)
>
> [참고자료 3](https://golf-dev.tistory.com/64)
> 
> 1절. 기본 배경
> 
> 2절. 컴파일러
>
> 3절. 인터프리터
>
> 4절. 차이점

## 1절. 사용 이유

#### 어셈블리 언어(Assembly Language)

- 기계어와 일대일 대응이 되는 컴퓨터 프로그래밍의 저급 언어
- 컴퓨터 구조에 따라 사용하는 기계어가 상이
- 기계어에 대응되어 만들어지는 어셈블리 언어 또한 상이

#### 컴파일(Compile)

- 컴퓨터가 고급 언어로 작성한 코드를 바로 인식하지 못해 번역하는 과정

#### 고급 프로그래밍 언어 발생 배경

- 컴퓨터 구조의 발전 
- 새로운 아키텍처가 적용된 CPU 생성
- 같은 프로그램을 새로 나온 CPU에 맞는 어셈블리어로 재작성 필요
- 즉, 통일된 언어 체계의 코드 필요

## 2절. 컴파일러

#### 정의

- "무언가를 모아서 묶음으로 만든다"

- 프로그램 전체를 스캔하여 모두 기계어로 한 번에 번역

#### 대표적인 컴파일러형 언어(Compiled Language)

- C
- C++
- C#
- CLEO
- COBOL
- Java

#### 해석 과정

1) 소스 코드 읽기<br>
: 컴파일러는 소스 코드 파일을 읽음

2) 어휘 분석<br>
: 소스 코드를 토큰이라는 작은 요소로 분해
   - 이 단계에서 컴파일러는 주석, 공백, 탭 문자 등을 제거 후 키워드, 연산자, 식별자, 리터럴 등의 토큰으로 분류

3) 구문 분석<br>
: 토큰들을 구조화 후 추상 구문 트리 생성
    - 이 단계에서 문법에 따라 토큰들을 조합하여 프로그램의 구조를 나타내는 트리 형태의 데이터 구조 생성

4) 의미 분석<br>
: 추상 구문 트리 검사 후 프로그램의 의미 검증
    - 타입 검사 변수의 정의 및 사용 검사, 함수 호출의 유효성 검사 등 수행
    - 오류 발견 시 컴파일러는 에러 메시지 생성 후 컴파일 과정 중단

5) 중간 코드 생성<br>
: 의미 분석 완료 시 추상 구문 트리를 중간 표현으로 변환
    - 중간 코드는 소스 코드와 기계어 사이에 있는 중간 단계
    - 컴파일러에 의해 추가적인 최적화 수행

6) 최적화<br>
: 중간 코드에 대한 다양한 최적화 기법 적용 후 프로그램의 실행 효율 향상
    - 이 단계에서 불필요한 코드 제거, 상수 폴딩, 루프 최적화 등의 작업 수행

7) 기계어 생성<br>
: 최적화된 중간 코드를 기계어(바이너리 코드)로 변환
    - 이 단계에서 기계어 명령어 생성 후 메모리 할당, 레지스터 할당 등과 같은 저수준 작업 수행

8) 링킹<br>
: 기계어로 변환된 코드에 필요한 외부 라이브러리, 함수, 모듈 등 연결

## 3절. 인터프리터

#### 정의

- "해석하다"

- 프로그램 실행 시 한 번에 한 문장씩만 기계어로 번역

#### 대표적인 해석형 언어(Interpreted Language)

- Python
- R
- Ruby
- Javascript

#### 해석 과정

1) 소스 코드 읽기<br>
: 소스 코드를 한 줄씩 읽기

2) 어휘 분석<br>
: 소스 코드를 토큰이라는 작은 요소로 분해 
    - 이 단계에서 컴파일러는 주석, 공백, 탭 문자 등을 제거하고 키워드, 연산자, 식별자, 리터럴 등의 토큰으로 분류

3) 구분 분석<br>
: 토큰들을 구조화 하여 추상 구문 트리를 생성
    - 이 단계에서 문법에 따라 토큰들을 조합하여 프로그램의 구조를 나타내는 트리 형태 데이터 구조 생성

4) 의미 분석<br>
: 추상 구문 트리를 검사하여 프로그램 의미 검증 
    - 타입 검사 변수의 정의 및 사용 검사, 함 수 호출의 유효성 검사 등이 수행
    - 오류가 발견되면 컴파일러는 에러 메시지를 생성하고 컴파일 과정을 중단

5) 실행<br>
: 의미가 분석 되면 추상 구문 트리를 순차적으로 실행
    - 이 단계에서 프로그램의 각 문장이 실행되고 변수 값이 계산되며, 함수 호출 
    - 인터프리터는 소스 코드를 한 줄씩 실행하므로, 실행 시점에서 소스 코드에 대한 변경사항이 즉시 반영

## 4절. 차이점

|종류|장점|단점|
|:---:|:---|:---|
|컴파일러(Compiler)|1. 초기 스캔은 오래걸리지만 한 번 스캔을 마치면 실행 파일을 만들고 계속 사용하기에 실행 속도가 인터프리터보다 빠름<br><br>2. 컴파일러는 오류 메시지 생성 시 전체 코드 검사 후 오류 메시지 생성. 즉, 프로그램 실행 전에 오류 발견 가능|1. 프로그램을 실행하는데 필요한 모든 파일을 스캔하기에 초기 스캔 시간이 오래걸림<br><br>2. 기계어 번역 시 오브젝트 코드(Object Code)라는 파일을 만드는데 이 오브젝트 코드를 다시 묶어 하나의 실행 파일로 다시 만드는 링킹(Linking) 작업 필요. 즉, 인터프리터보다 많은 메모리 사용|
|인터프리터(Interpreter)|1. 컴파일러처럼 목적 코드를 만들거나 하지 않고 링킹 과정도 거치지 않아 메모리 효율이 좋음<br><br>2. 코드 변경 시 빌드 과정 없이 바로 실행 가능하여 개발 속도에 장점|1. 컴파일러와 다르게 한 번에 한 문장씩 읽고 번역하여 실행시키는 과정을 반복하다 보니 실행이 조금 더 느림<br><br>2. 한 번에 한 문장씩 읽기에 프로그램을 실행해봐야지만 오류 발견 가능|

#### 그림으로 보기

<img src="https://github.com/BangYunseo/TIL/blob/main/Language/Image/ch00/ch00-01-CI.PNG"  width="50%" height="50%"/>

#### 정리

- 컴파일러(Compiler)
    - 코드를 기계어로 번역하는 과정에서 새로운 실행파일 생성

    - 실행 파일 생성으로 인해 인터프리터(Interpreter)에 비해 파일 크기 자체가 크고 수정이 필요한 경우 Re-compile 필수

    - 직접적으로 소스 코드를 노출 하지 않고 실행파일로 읽히기 때문에 보안적으로 안전
    
- 인터프리터(Interpreter)
    - 소스 코드를 한 줄씩 읽어들이면서 실행

    - 수정된 부분만 읽어들이기 때문에 수정 후 바로 실행이 되어 변경이 많은 경우 인터프리터(Interpreter)가 유리

- 이 외에 디버깅이 어렵고 쉽고의 차이 존재