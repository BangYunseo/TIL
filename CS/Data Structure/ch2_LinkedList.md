# chapter 2. 연결 리스트(Linked List)

### 1. 연결 리스트

![array](https://github.com/BangYunseo/TIL/blob/main/CS/Data%20Structure/%20Image/ch2/array.PNG)

#### (1) 배열이란 ? 연속된 메모리 공간에 순차적으로 저장된 데이터 모음
    - 데이터가 동일한 유형을 가지고 순서대로 접근    
    - 대부분에 프로그램 언어에서 동일 타입의 데이터를 저장    
    - 예를 들어 배열이 "int"타입인 경우
    - > 정수 요소만 저장할 수 있고 double, float, char 등과 같은 다른 타입의 요소는 저장할 수 없음    
    - 배열을 구성하는 각각의 값을 요소(element)라고 함      
    - 배열에서의 위치를 가리키는 숫자는 인덱스(index)라고 함    
    
#### (2) 예시     
    - 데이터 구조 수강생 명단을 저장할 때     
    - 염색체의 DNA 순서를 저장할 때      
    - 영상의 픽셀 값을 저장할 때
    - 순차적인 데이터를 저장하며 값보다는 순서가 중요할 때
    - 다차원 데이터를 다룰 때
    - 어떤 특정 요소를 빠르게 읽어야 할 때
    - 데이터 사이즈가 자주 바뀌지 않으며 요소가 자주 추가되거나 삭제되지 않을 때


#### (3) 배열 표현   

##### C언어의 배열 표현
  
![array2](https://github.com/BangYunseo/TIL/blob/main/CS/Data%20Structure/%20Image/ch1/array2.PNG)      

#### (4) 배열 표현을그림으로 나타낸 모습

![array3](https://github.com/BangYunseo/TIL/blob/main/CS/Data%20Structure/%20Image/ch1/array3.PNG)      
  
    - 연속된 메모리 공간에 데이터들은 순차적으로 저장됨     
    - ※ C에서 인덱스는 0부터 시작함 ※     
    - 배열 크기는 10이므로 10개의 요소를 저장함(index 0 ~ 9까지 총 10개)
    - 각 요소에 접근하기 위해서는 인덱스를 이용해야 함
    - > ex) array[0] = 35;     

#### (5) 특징

##### 1. 동일한 데이터 유형을 가짐     
        - 주로 동일한 데이터 유형을 가지지만 이질형 데이터도 지원 가능한 프로그래밍 언어도 존재      
        - 이질형 데이터들이 모인 집합체는 레코드라고 불림      
##### 2. 배열의 각 요소에 접근하는 시간은 O(1)로 모두 동일      
    - 기본 위치 + 오프셋(요소 크기 * 인덱스) 연산으로 모든 요소에 접근 가능     
##### 3. 연속된 메모리에 단일 블록화하여 데이터를 저장     
    - 낭비되는 공간이 거의 없음      
    - 하지만 큰 배열은 필요한 메모리를 할당하는 것이 불가능 할 수 있음     
##### 4. 실제 메모리 상에서 데이터는 순차적으로 저장되기 때문에 데이터에 순서가 있음
##### 5. index가 존재하여 indexing 및 slicing이 가능함
    - indexing : index를 이용하여 특정 요소를 리스트로부터 읽어들이는 것
    - slicing : 요소에 특정 부분을 따로 분리하고 조작하는 것

#### (6) 장단점

##### 1. 장점 
    - 인덱스를 이용한 접근이 가능하기 때문에 모든 요소에 빠른 접근
    - 기록 밀도가 1이기 때문에 낮은 공간 낭비
    - 배열은 부가정보 없이 데이터만 저장하기 때문에 기록 밀도가 1
    - 간단한 구현 
    - 효율적인 공간 활용     
    
##### 2. 단점
    - 배열을 선언한 후에는 할당된 정적 메모리로 인해 크기를 변경할 수 없음. 즉, 고정된 크기를 가짐
    - > 위의 단점 때문에 삽입과 삭제가 동적으로 발생하는 상황에서 적절한 배열의 크기를 미리 결정하는 것이 어려움
    - > 따라서, 오버플로우가 발생할 가능성이 높고 저장공간을 낭비할 가능성이 높음
    - 중간에 특정 요소를 삽입 및 삭제하는 경우 항상 메모리가 순차적으로 이어져 있어야 함
    - > 그러므로 삽입 및 삭제된 요소로부터 위에 있는 모든 요소들을 이동시켜주어야 함. 
    - 즉, 삽입 및 삭제에 많은 비용 소모
    - 범위를 벗어난 오류의 위험이 있을 수 있음 
    - 이질적인 데이터에 적합하지 않음


[보충 참고 자료](https://yoongrammer.tistory.com/43)


- 저장되는 데이터의 크기가      동적으로 변하고 리스트        중간에 있는 데이터를 삽입하거나 삭제해야 할 때 사용됨
- ex) 큐, 스택을 구현, 그래프를 구현할 때
     (양방향 연결 리스트)
- 장점 : 동적(시간에 따라 변화)인 크기, 효율적인 삽입과          삭제, 유연함
        (큐, 스택, 그래프를 구현할 때 나타나나는 장점)
- 단점 : 느린 접근, 구현하는 데 더 복잡함, 많은 양의            데이터를 저장하는 데 적합하지 않음
