# chapter 1. 배열(Array)

#### 배열

<img src="https://github.com/BangYunseo/TIL/blob/main/ComputerScience/DataStructure/Image/ch01/array.PNG" height="auto" />

- 연속된 메모리 공간에 순차적으로 저장된 데이터의 집합
- 데이터가 동일한 유형을 가지고 순서대로 접근
- 요소(element)
  - 배열을 구성하는 각각의 값
- 인덱스(index)
  - 배열에서의 위치를 가리키는 숫자

#### 예시

- 염색체의 DNA 순서를 저장할 때
- 영상의 픽셀 값을 저장할 때
- 순차적인 데이터를 저장하며 값보다는 순서가 중요할 때
- 다차원 데이터를 다룰 때
- 어떤 특정 요소를 빠르게 읽어야 할 때
- 데이터 사이즈가 자주 바뀌지 않으며 요소가 자주 추가되거나 삭제되지 않을 때

#### 배열 표현의 요소와 인덱스

![array3](https://github.com/BangYunseo/TIL/blob/main/ComputerScience/Data%20Structure/%20Image/ch01/array3.PNG)

- 연속된 메모리 공간에 데이터들은 순차적으로 저장
- 인덱스는 0부터 시작
- 배열 크기는 10이므로 10개의 요소를 저장(index 0 ~ 9까지 총 10개)
- 각 요소에 접근하기 위해서 인덱스 이용
  - ex) array[0] = 35;

#### 특징

- 동일한 데이터 유형
  - 주로 동일한 데이터 유형을 가지지만 이질형 데이터도 지원 가능한 프로그래밍 언어 존재
  - 이질형 데이터들이 모인 집합체는 레코드
- 기본 위치 + 오프셋(요소 크기 \* 인덱스) 연산으로 모든 요소에 접근 가능
- 연속된 메모리에 단일 블록화하여 데이터를 저장
  - 낭비되는 공간이 거의 없음
  - 큰 배열은 필요한 메모리를 할당하는 것이 불가능 할 가능성 존재
- 실제 메모리 상에서 데이터는 순차적으로 저장되기 때문에 데이터에 순서 존재
- index가 존재하여 indexing 및 slicing이 가능함
  - indexing : index를 이용하여 특정 요소를 리스트로부터 읽음
  - slicing : 요소에 특정 부분을 따로 분리하고 조작

#### 장점

- 인덱스를 이용한 접근이 가능하기 때문에 모든 요소에 빠른 접근
- 기록 밀도가 1이기 때문에 낮은 공간 낭비
- 배열은 부가정보 없이 데이터만 저장하기 때문에 기록 밀도가 1
- 간단한 구현
- 효율적인 공간 활용

#### 단점

- 배열을 선언한 후에는 할당된 정적 메모리로 인해 크기를 변경 불가능
- static한 크기
  - 위의 단점 때문에 삽입과 삭제가 동적으로 발생하는 상황에서 적절한 배열의 크기를 미리 결정하는 것에 불편
    - 오버플로우가 발생할 가능성이 높고 저장공간을 낭비할 가능성이 높음
- 중간에 특정 요소를 삽입 및 삭제하는 경우 항상 메모리가 순차적으로 이어짐
  - 삽입 및 삭제된 요소로부터 위에 있는 모든 요소들을 이동
  - 삽입 및 삭제에 많은 비용 소모
- 범위를 벗어난 오류의 위험
- 이질적인 데이터에 부적합

#### 구현

```python
# 1) 삽입 - 1
arr = []
for i in range(10):
 arr.append(i)
print(arr)
# 출력 예시
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# 2) 삽입 - 2
arr.insert(10, 'f')
print(arr)
# 출력 예시
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 'f']

# 3) 삭제
arr.remove(5)
arr.pop(0)
print(arr)
# 출력 예시
# [1, 2, 3, 4, 6, 7, 8, 9, 'f']

# 4) 탐색 - 1
print(arr.index(7))
# 출력 예시
# 5

# 5) 탐색 - 2
def finding(array, val):
    res = -1
    for a in array:
        res += 1
        if val == a:
            return res
    else:
        return -1
print(finding(arr, 15))
# 출력 예시
# -1
print(finding(arr, 'f'))
# 출력 예시
# 8
```

#### 시간 복잡도

- 자료 탐색 : O(1)
- 자료 삽입 및 삭제 : O(n)

[본문 참고 자료](https://yoongrammer.tistory.com/43)
